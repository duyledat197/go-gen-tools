package internal

import (
	"fmt"
	"runtime/debug"
	"strings"

	"github.com/common-nighthawk/go-figure"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/pluginpb"
)

type generator struct {
	f *protogen.File
	p *protogen.Plugin
}

func normalizeFullname(fn protoreflect.FullName) string {
	return strings.ReplaceAll(string(fn), ".", "_")
}

func (g *generator) GenerateMethods() {
	req := g.p.Request
	filename := g.f.GeneratedFilenamePrefix + "_methods.pb.go"
	genFile := g.p.NewGeneratedFile(filename, g.f.GoImportPath)
	fName := string(g.f.Desc.Name())
	custom := figure.NewFigure("custom", "", true)
	compilerVersion := "unknown"
	if v := req.GetCompilerVersion(); v != nil {
		compilerVersion = fmt.Sprintf("%d.%d.%d", v.GetMajor(), v.GetMinor(), v.GetPatch())
	}
	genFile.P("/* *")
	genFile.P(custom.String())
	genFile.P("*/")
	genFile.P("// * Code generated by protoc-gen-custom. DO NOT EDIT.")
	genFile.P("// * versions:")
	genFile.P("// * - protoc-gen-custom ", GetVersion(debug.ReadBuildInfo))
	genFile.P("// * - protoc                   v", compilerVersion)
	genFile.P("// * source: ", fName)
	genFile.P("")
	genFile.P("package ", g.f.GoPackageName)
	genFile.P("const (")
	for _, s := range g.f.Services {
		for _, m := range s.Methods {
			methodName := normalizeFullname(protoreflect.FullName(s.Desc.Name())) + "_" + string(m.Desc.Name())
			genFile.P("\t", methodName, ` = "/`, s.Desc.FullName(), "/", m.Desc.Name(), `"`)
		}
	}
	genFile.P(")")
}

func (g *generator) GenerateEnums() {
	req := g.p.Request
	filename := g.f.GeneratedFilenamePrefix + "_enums.pb.go"
	genFile := g.p.NewGeneratedFile(filename, g.f.GoImportPath)
	fName := string(g.f.Desc.Name())
	custom := figure.NewFigure("custom", "", true)

	compilerVersion := "unknown"
	if v := req.GetCompilerVersion(); v != nil {
		compilerVersion = fmt.Sprintf("%d.%d.%d", v.GetMajor(), v.GetMinor(), v.GetPatch())
	}
	genFile.P("/*")
	genFile.P(custom.String())
	genFile.P("*/")
	genFile.P("// * Code generated by protoc-gen-custom. DO NOT EDIT.")
	genFile.P("// * versions:")
	genFile.P("// * - protoc-gen-custom ", GetVersion(debug.ReadBuildInfo))
	genFile.P("// * - protoc                   v", compilerVersion)
	genFile.P("// * source: ", fName)
	genFile.P("")
	genFile.P("package ", g.f.GoPackageName)

	genFile.P("")
	for _, e := range g.f.Enums {
		name := e.Desc.Name()

		genFile.P("func (x ", name, ") FromString(str string) ", name, " {")
		genFile.P("\tswitch str {")
		for _, val := range e.Values {
			enumName := val.GoIdent.GoName
			genFile.P("\t\tcase ", enumName, ".String():")
			genFile.P("\t\t\treturn ", enumName)
		}
		genFile.P("\t}")
		genFile.P("\treturn ", name, "(0)")
		genFile.P("}\n")
	}
}

type BuildInfoReaderFunc = func() (*debug.BuildInfo, bool)

func GetVersion(infoReader BuildInfoReaderFunc) string {
	info, ok := infoReader()
	if !ok || info.Main.Version == "" {
		return "(unknown)"
	}
	return info.Main.Version
}

func Run(opt protogen.Options) {
	opt.Run(func(p *protogen.Plugin) error {
		p.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
		for _, f := range p.Files {
			if !f.Generate {
				continue
			}

			g := generator{f, p}
			g.GenerateMethods()
			g.GenerateEnums()
		}
		return nil
	})
}
